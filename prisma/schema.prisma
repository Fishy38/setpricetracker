// prisma/schema.prisma
generator client {
  provider   = "prisma-client-js"
  engineType = "library" // ✅ for edge functions, keep this
}

datasource db {
  provider = "postgresql"
}

/**
 * Keep this enum for code-side safety if you want it,
 * but we are NOT using it as the DB column type right now.
 * (We keep Offer/PriceHistory/Click.retailer as String to avoid migration breakage.)
 */
enum Retailer {
  LEGO
  Amazon
  Walmart
  Target
}

model Set {
  id               String    @id @default(cuid())
  setId            String    @unique
  name             String?
  imageUrl         String
  msrp             Int?
  legoUrl          String?
  canonicalUrl     String?
  rakutenProductId String?
  advertiserId     String?
  lastSyncedAt     DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  offers         Offer[]
  clicks         Click[]
  priceHistory   PriceHistory[]  @relation("SetPriceHistoryBySetId")
  outboundClicks OutboundClick[] // ✅ per-click tracking

  @@index([setId])
  @@index([updatedAt])
}

model Offer {
  id        String   @id @default(cuid())
  setIdRef  String
  retailer  String // ✅ keep as String for now (prevents enum migration failure)
  price     Int?
  url       String?
  inStock   Boolean?
  updatedAt DateTime @default(now())

  set Set @relation(fields: [setIdRef], references: [setId], onDelete: Cascade)

  @@unique([setIdRef, retailer])
  @@index([setIdRef])
  @@index([retailer])
  @@index([updatedAt])
}

model Click {
  id        String   @id @default(cuid())
  setIdRef  String
  retailer  String // ✅ keep as String for now (same reason)
  count     Int      @default(0)
  updatedAt DateTime @updatedAt

  set Set @relation(fields: [setIdRef], references: [setId], onDelete: Cascade)

  @@unique([setIdRef, retailer])
  @@index([setIdRef])
  @@index([retailer])
}

model PriceHistory {
  id         String   @id @default(cuid())
  setIdRef   String
  retailer   String // ✅ keep as String for now (prevents drop/recreate)
  price      Int?
  inStock    Boolean?
  recordedAt DateTime @default(now())

  set Set @relation("SetPriceHistoryBySetId", fields: [setIdRef], references: [setId], onDelete: Cascade)

  @@index([setIdRef])
  @@index([retailer])
  @@index([recordedAt])
  @@index([setIdRef, retailer, recordedAt])
}

/**
 * Gift cards are NOT LEGO sets. Separate table to keep the app clean.
 * Data source is Rakuten productsearch for giftcard.com (MID = RAKUTEN_GIFTCARD_MID).
 */
model GiftCardOffer {
  id String @id @default(cuid())

  // Rakuten product identifier (unique)
  rakutenProductId String @unique

  // Display
  name     String
  brand    String?
  imageUrl String?

  // Links
  destinationUrl String?
  affiliateUrl   String?
  canonicalUrl   String?

  // Optional pricing info if present
  price Int?

  // Source metadata
  advertiserId String?
  lastSyncedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  outboundClicks OutboundClick[] // ✅ per-click tracking

  @@index([updatedAt])
  @@index([brand])
  @@index([lastSyncedAt])
}

/**
 * Per-click outbound tracking for affiliate hijack detection + attribution debugging.
 *
 * Key idea: cid is generated by us per click and forced into Rakuten "u1" param.
 * Then Rakuten reports include u1, so you can reconcile clicks vs. credited sales.
 */
model OutboundClick {
  id  String @id @default(cuid())

  // Your click correlation id (also used as Rakuten "u1" where possible)
  cid String @unique

  // Optional set click
  setIdRef String?

  // Optional giftcard click (links to GiftCardOffer.rakutenProductId)
  giftCardRakutenProductId String?

  // Optional label from UI (keep as String for flexibility)
  retailer String?

  // Where we redirected to (after we inject u1 when applicable)
  destination     String
  destinationHost String?

  // Debug/forensics
  referrer String?
  ua       String?
  ipHash   String?

  createdAt DateTime @default(now())

  set      Set?          @relation(fields: [setIdRef], references: [setId], onDelete: SetNull)
  giftCard GiftCardOffer? @relation(fields: [giftCardRakutenProductId], references: [rakutenProductId], onDelete: SetNull)

  conversion AffiliateConversion?

  @@index([createdAt])
  @@index([setIdRef])
  @@index([giftCardRakutenProductId])
  @@index([retailer])
  @@index([destinationHost])
  @@index([ipHash])
}

/**
 * Attributed conversion row (imported from Rakuten reporting using u1=cid).
 * EPC is computed from commissionCents / clicks.
 */
model AffiliateConversion {
  id String @id @default(cuid())

  // u1 / click correlation id
  cid String @unique

  // Commission earned (in cents)
  commissionCents Int @default(0)

  // Optional: sale amount (in cents) if you import it
  saleAmountCents Int?

  // Optional: network name ("rakuten")
  network String @default("rakuten")

  // When the conversion happened (from report)
  occurredAt DateTime @default(now())

  click OutboundClick @relation(fields: [cid], references: [cid], onDelete: Cascade)

  @@index([occurredAt])
  @@index([network])
}